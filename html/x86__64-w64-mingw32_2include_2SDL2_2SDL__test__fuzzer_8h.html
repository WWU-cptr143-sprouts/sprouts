<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Sprouts: SDL2-2.0.3/x86_64-w64-mingw32/include/SDL2/SDL_test_fuzzer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Sprouts
   &#160;<span id="projectnumber">2014</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_674341710ad333de5afb6eac3d15e7d4.html">SDL2-2.0.3</a></li><li class="navelem"><a class="el" href="dir_8c9de10f29e15972e3b37d7d5e3db538.html">x86_64-w64-mingw32</a></li><li class="navelem"><a class="el" href="dir_79cae912589288175e004ba76b01661d.html">include</a></li><li class="navelem"><a class="el" href="dir_991214d92210de3fa125227ba688440a.html">SDL2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SDL_test_fuzzer.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;begin_code.h&quot;</code><br />
<code>#include &quot;close_code.h&quot;</code><br />
</div>
<p><a href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a623db129ea615326bed457ebb9703c1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#a623db129ea615326bed457ebb9703c1e">SDLTest_FuzzerInit</a> (<a class="el" href="structUint64.html">Uint64</a> execKey)</td></tr>
<tr class="separator:a623db129ea615326bed457ebb9703c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af942b620c7418ec3d47a0610b94e8337"><td class="memItemLeft" align="right" valign="top">Uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#af942b620c7418ec3d47a0610b94e8337">SDLTest_RandomUint8</a> ()</td></tr>
<tr class="separator:af942b620c7418ec3d47a0610b94e8337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf54a1586a83ad3f4873e0111d0202e7"><td class="memItemLeft" align="right" valign="top">Sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#acf54a1586a83ad3f4873e0111d0202e7">SDLTest_RandomSint8</a> ()</td></tr>
<tr class="separator:acf54a1586a83ad3f4873e0111d0202e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98beae757a943595d32aafee88cc4da1"><td class="memItemLeft" align="right" valign="top">Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#a98beae757a943595d32aafee88cc4da1">SDLTest_RandomUint16</a> ()</td></tr>
<tr class="separator:a98beae757a943595d32aafee88cc4da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1be2df94dde429c7fe936e2a4efea39"><td class="memItemLeft" align="right" valign="top">Sint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#ae1be2df94dde429c7fe936e2a4efea39">SDLTest_RandomSint16</a> ()</td></tr>
<tr class="separator:ae1be2df94dde429c7fe936e2a4efea39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67535fd617b059fccc8ddb52e34aed0"><td class="memItemLeft" align="right" valign="top">Sint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#ac67535fd617b059fccc8ddb52e34aed0">SDLTest_RandomSint32</a> ()</td></tr>
<tr class="separator:ac67535fd617b059fccc8ddb52e34aed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815bd0547ea1c3bed6a60ae4e96cd597"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#a815bd0547ea1c3bed6a60ae4e96cd597">SDLTest_RandomUint32</a> ()</td></tr>
<tr class="separator:a815bd0547ea1c3bed6a60ae4e96cd597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d08f09338fb5f8e4b67a5d7e67231fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structUint64.html">Uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#a5d08f09338fb5f8e4b67a5d7e67231fd">SDLTest_RandomUint64</a> ()</td></tr>
<tr class="separator:a5d08f09338fb5f8e4b67a5d7e67231fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e7c4c94ce61cc6f8fe6bc976662de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structUint64.html">Sint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#ae7e7c4c94ce61cc6f8fe6bc976662de0">SDLTest_RandomSint64</a> ()</td></tr>
<tr class="separator:ae7e7c4c94ce61cc6f8fe6bc976662de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185df1c7d2cf7af44119bc9b87310b29"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#a185df1c7d2cf7af44119bc9b87310b29">SDLTest_RandomUnitFloat</a> ()</td></tr>
<tr class="separator:a185df1c7d2cf7af44119bc9b87310b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48d4a95e2f80651b8c7200fb4d0b671"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#af48d4a95e2f80651b8c7200fb4d0b671">SDLTest_RandomUnitDouble</a> ()</td></tr>
<tr class="separator:af48d4a95e2f80651b8c7200fb4d0b671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67cbb94c2868d3ee7aaeddc5c01705f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#ac67cbb94c2868d3ee7aaeddc5c01705f">SDLTest_RandomFloat</a> ()</td></tr>
<tr class="separator:ac67cbb94c2868d3ee7aaeddc5c01705f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f2dff59dec57742c4fe1ed47aaac8f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#ac6f2dff59dec57742c4fe1ed47aaac8f">SDLTest_RandomDouble</a> ()</td></tr>
<tr class="separator:ac6f2dff59dec57742c4fe1ed47aaac8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129a58a37dc23847b8257569bf56d16f"><td class="memItemLeft" align="right" valign="top">Uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#a129a58a37dc23847b8257569bf56d16f">SDLTest_RandomUint8BoundaryValue</a> (Uint8 boundary1, Uint8 boundary2, SDL_bool validDomain)</td></tr>
<tr class="separator:a129a58a37dc23847b8257569bf56d16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3710dba14db764872949252f558429ba"><td class="memItemLeft" align="right" valign="top">Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#a3710dba14db764872949252f558429ba">SDLTest_RandomUint16BoundaryValue</a> (Uint16 boundary1, Uint16 boundary2, SDL_bool validDomain)</td></tr>
<tr class="separator:a3710dba14db764872949252f558429ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e718145eaf96f611cd67fc530473e3a"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#a9e718145eaf96f611cd67fc530473e3a">SDLTest_RandomUint32BoundaryValue</a> (Uint32 boundary1, Uint32 boundary2, SDL_bool validDomain)</td></tr>
<tr class="separator:a9e718145eaf96f611cd67fc530473e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc660d9b04554c8c2717325224b88b6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structUint64.html">Uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#abc660d9b04554c8c2717325224b88b6a">SDLTest_RandomUint64BoundaryValue</a> (<a class="el" href="structUint64.html">Uint64</a> boundary1, <a class="el" href="structUint64.html">Uint64</a> boundary2, SDL_bool validDomain)</td></tr>
<tr class="separator:abc660d9b04554c8c2717325224b88b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ec06adf1ca58afa5283be6b4f5fdfc"><td class="memItemLeft" align="right" valign="top">Sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#a09ec06adf1ca58afa5283be6b4f5fdfc">SDLTest_RandomSint8BoundaryValue</a> (Sint8 boundary1, Sint8 boundary2, SDL_bool validDomain)</td></tr>
<tr class="separator:a09ec06adf1ca58afa5283be6b4f5fdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11fb12560b1a9180b1645d6ca1c6af6"><td class="memItemLeft" align="right" valign="top">Sint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#ae11fb12560b1a9180b1645d6ca1c6af6">SDLTest_RandomSint16BoundaryValue</a> (Sint16 boundary1, Sint16 boundary2, SDL_bool validDomain)</td></tr>
<tr class="separator:ae11fb12560b1a9180b1645d6ca1c6af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17fbfddfa253bb3d64412000488fc07"><td class="memItemLeft" align="right" valign="top">Sint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#ab17fbfddfa253bb3d64412000488fc07">SDLTest_RandomSint32BoundaryValue</a> (Sint32 boundary1, Sint32 boundary2, SDL_bool validDomain)</td></tr>
<tr class="separator:ab17fbfddfa253bb3d64412000488fc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6a8004aba7d72595f80540fa0b6727"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structUint64.html">Sint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#a0b6a8004aba7d72595f80540fa0b6727">SDLTest_RandomSint64BoundaryValue</a> (<a class="el" href="structUint64.html">Sint64</a> boundary1, <a class="el" href="structUint64.html">Sint64</a> boundary2, SDL_bool validDomain)</td></tr>
<tr class="separator:a0b6a8004aba7d72595f80540fa0b6727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c81f42e213ad1608cf5f29669eb8521"><td class="memItemLeft" align="right" valign="top">Sint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#a5c81f42e213ad1608cf5f29669eb8521">SDLTest_RandomIntegerInRange</a> (Sint32 min, Sint32 max)</td></tr>
<tr class="separator:a5c81f42e213ad1608cf5f29669eb8521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad690953f6429253a769072713d06be1d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#ad690953f6429253a769072713d06be1d">SDLTest_RandomAsciiString</a> ()</td></tr>
<tr class="separator:ad690953f6429253a769072713d06be1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16734124f5caad4459ce8f41ad7a7f21"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#a16734124f5caad4459ce8f41ad7a7f21">SDLTest_RandomAsciiStringWithMaximumLength</a> (int maxLength)</td></tr>
<tr class="separator:a16734124f5caad4459ce8f41ad7a7f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e788507091b26d95d47a2e273dc6164"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#a8e788507091b26d95d47a2e273dc6164">SDLTest_RandomAsciiStringOfSize</a> (int size)</td></tr>
<tr class="separator:a8e788507091b26d95d47a2e273dc6164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026be35faa8ecc197f2a9e5737e48a08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h.html#a026be35faa8ecc197f2a9e5737e48a08">SDLTest_GetFuzzerInvocationCount</a> ()</td></tr>
<tr class="separator:a026be35faa8ecc197f2a9e5737e48a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Note: The fuzzer implementation uses a static instance of random context internally which makes it thread-UNsafe. </p>

<p>Definition in file <a class="el" href="x86__64-w64-mingw32_2include_2SDL2_2SDL__test__fuzzer_8h_source.html">SDL_test_fuzzer.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a623db129ea615326bed457ebb9703c1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDLTest_FuzzerInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUint64.html">Uint64</a>&#160;</td>
          <td class="paramname"><em>execKey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the fuzzer for a test</p>
<p>/param execKey Execution "Key" that initializes the random number generator uniquely for the test. </p>

</div>
</div>
<a class="anchor" id="a026be35faa8ecc197f2a9e5737e48a08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SDLTest_GetFuzzerInvocationCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the invocation count for the fuzzer since last ...FuzzerInit. </p>

</div>
</div>
<a class="anchor" id="ad690953f6429253a769072713d06be1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* SDLTest_RandomAsciiString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates random null-terminated string. The minimum length for the string is 1 character, maximum length for the string is 255 characters and it can contain ASCII characters from 32 to 126.</p>
<p>Note: Returned string needs to be deallocated.</p>
<dl class="section return"><dt>Returns</dt><dd>Newly allocated random string; or NULL if length was invalid or string could not be allocated. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e788507091b26d95d47a2e273dc6164"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* SDLTest_RandomAsciiStringOfSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates random null-terminated string. The length for the string is defined by the size parameter. String can contain ASCII characters from 32 to 126.</p>
<p>Note: Returned string needs to be deallocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The length of the generated string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly allocated random string; or NULL if size was invalid or string could not be allocated. </dd></dl>

</div>
</div>
<a class="anchor" id="a16734124f5caad4459ce8f41ad7a7f21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* SDLTest_RandomAsciiStringWithMaximumLength </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates random null-terminated string. The maximum length for the string is defined by the maxLength parameter. String can contain ASCII characters from 32 to 126.</p>
<p>Note: Returned string needs to be deallocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxLength</td><td>The maximum length of the generated string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly allocated random string; or NULL if maxLength was invalid or string could not be allocated. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6f2dff59dec57742c4fe1ed47aaac8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDLTest_RandomDouble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>random double. </dd></dl>

</div>
</div>
<a class="anchor" id="ac67cbb94c2868d3ee7aaeddc5c01705f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SDLTest_RandomFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>random float. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c81f42e213ad1608cf5f29669eb8521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sint32 SDLTest_RandomIntegerInRange </td>
          <td>(</td>
          <td class="paramtype">Sint32&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sint32&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns integer in range [min, max] (inclusive). Min and max values can be negative values. If Max in smaller tham min, then the values are swapped. Min and max are the same value, that value will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>Minimum inclusive value of returned random number </td></tr>
    <tr><td class="paramname">max</td><td>Maximum inclusive value of returned random number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Generated random integer in range </dd></dl>

</div>
</div>
<a class="anchor" id="ae1be2df94dde429c7fe936e2a4efea39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sint16 SDLTest_RandomSint16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random Sint16</p>
<dl class="section return"><dt>Returns</dt><dd>Generated signed integer </dd></dl>

</div>
</div>
<a class="anchor" id="ae11fb12560b1a9180b1645d6ca1c6af6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sint16 SDLTest_RandomSint16BoundaryValue </td>
          <td>(</td>
          <td class="paramtype">Sint16&#160;</td>
          <td class="paramname"><em>boundary1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sint16&#160;</td>
          <td class="paramname"><em>boundary2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_bool&#160;</td>
          <td class="paramname"><em>validDomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random boundary value for Sint16 within the given boundaries. Boundaries are inclusive, see the usage examples below. If validDomain is true, the function will only return valid boundaries, otherwise non-valid boundaries are also possible. If boundary1 &gt; boundary2, the values are swapped</p>
<p>Usage examples: RandomSint16BoundaryValue(-10, 20, SDL_TRUE) returns -11, -10, 19 or 20 RandomSint16BoundaryValue(-100, -10, SDL_FALSE) returns -101 or -9 RandomSint16BoundaryValue(SINT16_MIN, 99, SDL_FALSE) returns 100 RandomSint16BoundaryValue(SINT16_MIN, SINT16_MAX, SDL_FALSE) returns SINT16_MIN (== error value) with error set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundary1</td><td>Lower boundary limit </td></tr>
    <tr><td class="paramname">boundary2</td><td>Upper boundary limit </td></tr>
    <tr><td class="paramname">validDomain</td><td>Should the generated boundary be valid (=within the bounds) or not?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random boundary value for the given range and domain or SINT16_MIN with error set </dd></dl>

</div>
</div>
<a class="anchor" id="ac67535fd617b059fccc8ddb52e34aed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sint32 SDLTest_RandomSint32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random integer</p>
<dl class="section return"><dt>Returns</dt><dd>Generated integer </dd></dl>

</div>
</div>
<a class="anchor" id="ab17fbfddfa253bb3d64412000488fc07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sint32 SDLTest_RandomSint32BoundaryValue </td>
          <td>(</td>
          <td class="paramtype">Sint32&#160;</td>
          <td class="paramname"><em>boundary1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sint32&#160;</td>
          <td class="paramname"><em>boundary2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_bool&#160;</td>
          <td class="paramname"><em>validDomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random boundary value for Sint32 within the given boundaries. Boundaries are inclusive, see the usage examples below. If validDomain is true, the function will only return valid boundaries, otherwise non-valid boundaries are also possible. If boundary1 &gt; boundary2, the values are swapped</p>
<p>Usage examples: RandomSint32BoundaryValue(-10, 20, SDL_TRUE) returns -11, -10, 19 or 20 RandomSint32BoundaryValue(-100, -10, SDL_FALSE) returns -101 or -9 RandomSint32BoundaryValue(SINT32_MIN, 99, SDL_FALSE) returns 100 RandomSint32BoundaryValue(SINT32_MIN, SINT32_MAX, SDL_FALSE) returns SINT32_MIN (== error value)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundary1</td><td>Lower boundary limit </td></tr>
    <tr><td class="paramname">boundary2</td><td>Upper boundary limit </td></tr>
    <tr><td class="paramname">validDomain</td><td>Should the generated boundary be valid (=within the bounds) or not?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random boundary value for the given range and domain or SINT32_MIN with error set </dd></dl>

</div>
</div>
<a class="anchor" id="ae7e7c4c94ce61cc6f8fe6bc976662de0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structUint64.html">Sint64</a> SDLTest_RandomSint64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns random Sint64.</p>
<dl class="section return"><dt>Returns</dt><dd>Generated signed integer </dd></dl>

</div>
</div>
<a class="anchor" id="a0b6a8004aba7d72595f80540fa0b6727"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structUint64.html">Sint64</a> SDLTest_RandomSint64BoundaryValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUint64.html">Sint64</a>&#160;</td>
          <td class="paramname"><em>boundary1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUint64.html">Sint64</a>&#160;</td>
          <td class="paramname"><em>boundary2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_bool&#160;</td>
          <td class="paramname"><em>validDomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random boundary value for Sint64 within the given boundaries. Boundaries are inclusive, see the usage examples below. If validDomain is true, the function will only return valid boundaries, otherwise non-valid boundaries are also possible. If boundary1 &gt; boundary2, the values are swapped</p>
<p>Usage examples: RandomSint64BoundaryValue(-10, 20, SDL_TRUE) returns -11, -10, 19 or 20 RandomSint64BoundaryValue(-100, -10, SDL_FALSE) returns -101 or -9 RandomSint64BoundaryValue(SINT64_MIN, 99, SDL_FALSE) returns 100 RandomSint64BoundaryValue(SINT64_MIN, SINT64_MAX, SDL_FALSE) returns SINT64_MIN (== error value) and error set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundary1</td><td>Lower boundary limit </td></tr>
    <tr><td class="paramname">boundary2</td><td>Upper boundary limit </td></tr>
    <tr><td class="paramname">validDomain</td><td>Should the generated boundary be valid (=within the bounds) or not?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random boundary value for the given range and domain or SINT64_MIN with error set </dd></dl>

</div>
</div>
<a class="anchor" id="acf54a1586a83ad3f4873e0111d0202e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sint8 SDLTest_RandomSint8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random Sint8</p>
<dl class="section return"><dt>Returns</dt><dd>Generated signed integer </dd></dl>

</div>
</div>
<a class="anchor" id="a09ec06adf1ca58afa5283be6b4f5fdfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sint8 SDLTest_RandomSint8BoundaryValue </td>
          <td>(</td>
          <td class="paramtype">Sint8&#160;</td>
          <td class="paramname"><em>boundary1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sint8&#160;</td>
          <td class="paramname"><em>boundary2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_bool&#160;</td>
          <td class="paramname"><em>validDomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random boundary value for Sint8 within the given boundaries. Boundaries are inclusive, see the usage examples below. If validDomain is true, the function will only return valid boundaries, otherwise non-valid boundaries are also possible. If boundary1 &gt; boundary2, the values are swapped</p>
<p>Usage examples: RandomSint8BoundaryValue(-10, 20, SDL_TRUE) returns -11, -10, 19 or 20 RandomSint8BoundaryValue(-100, -10, SDL_FALSE) returns -101 or -9 RandomSint8BoundaryValue(SINT8_MIN, 99, SDL_FALSE) returns 100 RandomSint8BoundaryValue(SINT8_MIN, SINT8_MAX, SDL_FALSE) returns SINT8_MIN (== error value) with error set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundary1</td><td>Lower boundary limit </td></tr>
    <tr><td class="paramname">boundary2</td><td>Upper boundary limit </td></tr>
    <tr><td class="paramname">validDomain</td><td>Should the generated boundary be valid (=within the bounds) or not?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random boundary value for the given range and domain or SINT8_MIN with error set </dd></dl>

</div>
</div>
<a class="anchor" id="a98beae757a943595d32aafee88cc4da1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint16 SDLTest_RandomUint16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random Uint16</p>
<dl class="section return"><dt>Returns</dt><dd>Generated integer </dd></dl>

</div>
</div>
<a class="anchor" id="a3710dba14db764872949252f558429ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint16 SDLTest_RandomUint16BoundaryValue </td>
          <td>(</td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>boundary1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>boundary2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_bool&#160;</td>
          <td class="paramname"><em>validDomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random boundary value for Uint16 within the given boundaries. Boundaries are inclusive, see the usage examples below. If validDomain is true, the function will only return valid boundaries, otherwise non-valid boundaries are also possible. If boundary1 &gt; boundary2, the values are swapped</p>
<p>Usage examples: RandomUint16BoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20 RandomUint16BoundaryValue(1, 20, SDL_FALSE) returns 0 or 21 RandomUint16BoundaryValue(0, 99, SDL_FALSE) returns 100 RandomUint16BoundaryValue(0, 0xFFFF, SDL_FALSE) returns 0 (error set)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundary1</td><td>Lower boundary limit </td></tr>
    <tr><td class="paramname">boundary2</td><td>Upper boundary limit </td></tr>
    <tr><td class="paramname">validDomain</td><td>Should the generated boundary be valid (=within the bounds) or not?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random boundary value for the given range and domain or 0 with error set </dd></dl>

</div>
</div>
<a class="anchor" id="a815bd0547ea1c3bed6a60ae4e96cd597"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 SDLTest_RandomUint32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random positive integer</p>
<dl class="section return"><dt>Returns</dt><dd>Generated integer </dd></dl>

</div>
</div>
<a class="anchor" id="a9e718145eaf96f611cd67fc530473e3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 SDLTest_RandomUint32BoundaryValue </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>boundary1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>boundary2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_bool&#160;</td>
          <td class="paramname"><em>validDomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random boundary value for Uint32 within the given boundaries. Boundaries are inclusive, see the usage examples below. If validDomain is true, the function will only return valid boundaries, otherwise non-valid boundaries are also possible. If boundary1 &gt; boundary2, the values are swapped</p>
<p>Usage examples: RandomUint32BoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20 RandomUint32BoundaryValue(1, 20, SDL_FALSE) returns 0 or 21 RandomUint32BoundaryValue(0, 99, SDL_FALSE) returns 100 RandomUint32BoundaryValue(0, 0xFFFFFFFF, SDL_FALSE) returns 0 (with error set)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundary1</td><td>Lower boundary limit </td></tr>
    <tr><td class="paramname">boundary2</td><td>Upper boundary limit </td></tr>
    <tr><td class="paramname">validDomain</td><td>Should the generated boundary be valid (=within the bounds) or not?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random boundary value for the given range and domain or 0 with error set </dd></dl>

</div>
</div>
<a class="anchor" id="a5d08f09338fb5f8e4b67a5d7e67231fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structUint64.html">Uint64</a> SDLTest_RandomUint64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns random <a class="el" href="structUint64.html">Uint64</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Generated integer </dd></dl>

</div>
</div>
<a class="anchor" id="abc660d9b04554c8c2717325224b88b6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structUint64.html">Uint64</a> SDLTest_RandomUint64BoundaryValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUint64.html">Uint64</a>&#160;</td>
          <td class="paramname"><em>boundary1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUint64.html">Uint64</a>&#160;</td>
          <td class="paramname"><em>boundary2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_bool&#160;</td>
          <td class="paramname"><em>validDomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random boundary value for <a class="el" href="structUint64.html">Uint64</a> within the given boundaries. Boundaries are inclusive, see the usage examples below. If validDomain is true, the function will only return valid boundaries, otherwise non-valid boundaries are also possible. If boundary1 &gt; boundary2, the values are swapped</p>
<p>Usage examples: RandomUint64BoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20 RandomUint64BoundaryValue(1, 20, SDL_FALSE) returns 0 or 21 RandomUint64BoundaryValue(0, 99, SDL_FALSE) returns 100 RandomUint64BoundaryValue(0, 0xFFFFFFFFFFFFFFFF, SDL_FALSE) returns 0 (with error set)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundary1</td><td>Lower boundary limit </td></tr>
    <tr><td class="paramname">boundary2</td><td>Upper boundary limit </td></tr>
    <tr><td class="paramname">validDomain</td><td>Should the generated boundary be valid (=within the bounds) or not?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random boundary value for the given range and domain or 0 with error set </dd></dl>

</div>
</div>
<a class="anchor" id="af942b620c7418ec3d47a0610b94e8337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint8 SDLTest_RandomUint8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random Uint8</p>
<dl class="section return"><dt>Returns</dt><dd>Generated integer </dd></dl>

</div>
</div>
<a class="anchor" id="a129a58a37dc23847b8257569bf56d16f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint8 SDLTest_RandomUint8BoundaryValue </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>boundary1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>boundary2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_bool&#160;</td>
          <td class="paramname"><em>validDomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random boundary value for Uint8 within the given boundaries. Boundaries are inclusive, see the usage examples below. If validDomain is true, the function will only return valid boundaries, otherwise non-valid boundaries are also possible. If boundary1 &gt; boundary2, the values are swapped</p>
<p>Usage examples: RandomUint8BoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20 RandomUint8BoundaryValue(1, 20, SDL_FALSE) returns 0 or 21 RandomUint8BoundaryValue(0, 99, SDL_FALSE) returns 100 RandomUint8BoundaryValue(0, 255, SDL_FALSE) returns 0 (error set)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundary1</td><td>Lower boundary limit </td></tr>
    <tr><td class="paramname">boundary2</td><td>Upper boundary limit </td></tr>
    <tr><td class="paramname">validDomain</td><td>Should the generated boundary be valid (=within the bounds) or not?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random boundary value for the given range and domain or 0 with error set </dd></dl>

</div>
</div>
<a class="anchor" id="af48d4a95e2f80651b8c7200fb4d0b671"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDLTest_RandomUnitDouble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>random double in range [0.0 - 1.0[ </dd></dl>

</div>
</div>
<a class="anchor" id="a185df1c7d2cf7af44119bc9b87310b29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SDLTest_RandomUnitFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>random float in range [0.0 - 1.0[ </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon May 26 2014 18:34:01 for Sprouts by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
